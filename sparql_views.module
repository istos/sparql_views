<?php
// $Id$

/**
 * SPARQL Views
 *
 * The SPARQL Views module enables the creation of SPARQL queries in Views.
 * SPARQL is a query language for accessing RDF datastores, frequently to access
 * remote datastores using HTTP.
 */

include_once (drupal_get_path('module', 'rdfx') .'/rdfx.sparql.inc');
include_once (drupal_get_path('module', 'rdfx') .'/rdfx.import.inc');

/**
 * Implements hook_views_api().
 */
function sparql_views_views_api() {
  return array(
    'api' => '3.0-alpha1',
  );
}

/**
 * Implements hook_menu().
 */
function sparql_views_menu() {
  $items['sparql_views/autocomplete/subject-object/%/%'] = array(
    'title' => 'SPARQL variables autocomplete',
    'page callback' => 'sparql_views_variables_autocomplete',
    'access arguments' => array('administer views'),
    'type' => MENU_CALLBACK,
    'file' => 'sparql_views.pages.inc',
  );
  $items['sparql_views/autocomplete/predicate'] = array(
    'title' => 'SPARQL variables autocomplete',
    'page callback' => 'sparql_views_predicates_autocomplete',
    'access arguments' => array('administer views'),
    'type' => MENU_CALLBACK,
    'file' => 'sparql_views.pages.inc',
  );
  $items['sparql_views/prefixes/autocomplete'] = array(
    'title' => 'Endpoint predicate loader',
    'page callback' => 'sparql_views_autocomplete_prefixes',
    'access arguments' => array('administer views'),
    'type' => MENU_CALLBACK,
    'file' => 'sparql_views.pages.inc',
  );

  return $items;
}

/*
 * Helper function to retrieve the variables that have been entered in filters.
 * These variables are used as the fields in Views.
 */
function _sparql_views_get_fields($view = NULL, $display_name = NULL) {
  $fields = array();
  $sparql_view_names = array();

  if ($view != NULL && $display_name != NULL) {
    $fields = _sparql_views_get_filters($view, $display_name);
  }
  else if ($view != NULL) {
    $fields = _sparql_views_get_filters($view, 'default');
  }

  //@todo Move this to _sparql_views_get_all_fields which could be Drupal static.
  else {
    $views = views_get_all_views();
    foreach ($views as $view_name => $view) {
      $query_type = $view->display['default']->display_options['query']['type'];
      if ($query_type == 'sparql_query') {
        $sparql_view_names[] = $view_name;
      }
    }
    foreach ($sparql_view_names as $view_name) {
      // Get the view the user is editing based on the URL.
      $view = views_ui_cache_load($view_name);

      foreach ($view->display as $display_name => $display) {
        $fields = _sparql_views_get_filters($view, $display_name);
      }
    }
  }

  return $fields;
}

function _sparql_views_get_filters($view = NULL, $display_name = NULL) {
  $fields = array();

  $default_filters = $view->display['default']->display_options['filters'];
  $display_filters = $view->display[$display_name]->display_options['filters'];

  // If where clauses haven't been added to the default or the display, there
  // are no added fields.
  if (empty($default_filters) && empty($display_filters)) {
    return array();
  }
  // Else, if where clauses have been added to the default but not to the
  // display, use the default where clauses.
  else if (empty($display_filters)) {
    $display_filters = $default_filters;
  }

  // Iterate through the where clauses and pull out the variables.
  foreach ($display_filters as $filter) {
    // If there is an empty Where clause, $filter will not have values.
    if (!empty($filter['value'])) {
      foreach ($filter['value'] as $value) {
        if (strpos($value, '?') === 0) {
          $field = substr($value, 1);
          $fields[$field] = $field;
        }
      }
    }
  }

  return $fields;
}

/*
 * Get namespace mappings from prefix.cc.
 * @todo This functionality still needs to be implemented.
 */
function _sparql_views_fetch_prefixes() {
  // @todo Use Drupal cache.
  $results = rdfx_fetch_rdf('http://prefix.cc/popular/all.rdf.plain', 'prefix');
  return $results[1];
}

