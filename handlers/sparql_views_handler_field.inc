<?php
// $Id$

class sparql_views_handler_field extends views_handler_field {
  /**
   * Add SPARQL query specific field options.
   */
  function option_definition() {
    $options = parent::option_definition();

    $options['alter']['contains']['combine_values'] = array('default' => FALSE);

    return $options;
  }
  
  /**
   * Add form elements for SPARQL query specific field options.
   */
  function options_form(&$form, &$form_state) {
    parent::options_form($form, $form_state);
        $form['alter']['combine_values'] = array(
        '#type' => 'checkbox',
        '#title' => t('Combine multiple values'),
        '#description' => t('If checked, rows that contain all the same values except for this field will be combined and this field will become a multivalue field.'),
        '#default_value' => $this->options['alter']['combine_values'],
      );
  }

  /**
   * Called to add the field to a query.
   */
  function query() {
    $this->field_alias = $this->real_field;
  }

  function pre_render(&$values) {
    static $sparql_views_storage;

    // If this is the first time through the function pre_render, create an
    // array representing the rows to combine.
    reset($this->view->field);
    $first_key = key($this->view->field);
    if ($this->field_alias == $first_key && count($values) > 1) {
      $sparql_views_storage['combine'] = _sparql_views_calc_row_combinations($this, $values);
    }

    // For each field, iterate through and combine values as defined in
    // $sparql_views_storage['combine'] array.
    foreach ($values as $key => $value) {
      $items = array();
      $field = $value[$this->field_alias];

      // Copy the untampered field value into a storage array.
      if (!isset($sparql_views_storage['field_values'][$this->field_alias][$key])) {
        $sparql_views_storage['field_values'][$this->field_alias][$key] = $field;
      }
      $token = $this->options['alter']['path'];
      // If this field is linked to another field, then add the token in a path.
      if (!empty($token)) {
        $token_fieldname = preg_replace('/\[|\]/', '', $token);
        $link = isset($sparql_views_storage['field_values'][$token_fieldname][$key]) ? $sparql_views_storage['field_values'][$token_fieldname][$key] : $value[$token_fieldname];
      }
      if (!empty($field)) {
        $items[] = array('field' => $field, 'token' => array($token => $link));
      }
      
      if (isset($sparql_views_storage['combine'][$key][$this->field_alias])) {
        $rows_to_combine = $sparql_views_storage['combine'][$key][$this->field_alias];
        foreach ($rows_to_combine as $row) {
          if (!isset($sparql_views_storage['field_values'][$this->field_alias][$row])) {
            $field = $values[$row][$this->field_alias];
            $sparql_views_storage['field_values'][$this->field_alias][$row] = $field;
          }
          $token = $this->options['alter']['path'];
          if (!empty($token)) {
            $token_fieldname = preg_replace('/\[|\]/', '', $token);
            $link = isset($sparql_views_storage['field_values'][$token_fieldname][$row]) ? $sparql_views_storage['field_values'][$token_fieldname][$row] : $values[$row][$token_fieldname];
          }
          if (!empty($field)) {
            $items[] = array('field' => $field, 'token' => array($token => $link));
          }
          $values[$row]['rendered'] = TRUE;
          unset($values[$row]);
        }
      }
      $values[$key][$this->field_alias] = $items;
    }
  }

  function get_items($values) {
    $items = $values[$this->field_alias];
    return $items;
  }

  // We need to include this override in order to use get_items.
  function render_item($count, $item) {
    return $item;
  }

  function render_items($items) {
    $this->options['type'] = 'separator';
    $this->options['separator'] = ' || ';
    if (!empty($items)) {
      if ($this->options['type'] == 'separator') {
        return implode(check_plain($this->options['separator']), $items);
      }
      else {
        return theme('item_list', $items, NULL, $this->options['type']);
      }
    }
  }

  /**
   * Render a field using advanced settings.
   *
   * This renders a field normally, then decides if render-as-link and
   * text-replacement rendering is necessary.
   */
  function advanced_render($values) {
    if ($this->allow_advanced_render() && method_exists($this, 'render_item')) {
      $raw_items = $this->get_items($values);
    }
    else {
      $this->last_render = $value = $this->render($values);
      $this->original_value = $value;
    }

    if ($this->allow_advanced_render()) {
      $tokens = NULL;
      if (method_exists($this, 'render_item')) {
        $items = array();
        foreach ($raw_items as $count => $item) {
          $rendered = $this->render_item($count, $item);
          $this->last_render = $rendered['field'];
          $this->original_value = $this->last_render;

          $alter = $item + $this->options['alter'];
          $items[] = $this->render_text($alter);
        }

        $value = $this->render_items($items);
      }
      else {
        $value = $this->render_text($this->options['alter']);
      }

      // This happens here so that render_as_link can get the unaltered value of
      // this field as a token rather than the altered value.
      $this->last_render = $value;
    }

    if (empty($this->last_render)) {
      if (($this->last_render !== 0 && $this->last_render !== '0') || !empty($this->options['empty_zero'])) {
        $this->last_render = $this->options['empty'];
      }
    }

    return $this->last_render;
  }

  /**
   * Get the 'render' tokens to use for advanced rendering.
   *
   * This runs through all of the fields and arguments that
   * are available and gets their values. This will then be
   * used in one giant str_replace().
   */
  function get_render_tokens($item) {
    $tokens = array();
    if (!empty($this->view->build_info['substitutions'])) {
      $tokens = $this->view->build_info['substitutions'];
    }
    $count = 0;
    foreach ($this->view->display_handler->get_handlers('argument') as $arg => $handler) {
      $token = '%'. ++$count;
      if (!isset($tokens[$token])) {
        $tokens[$token] = '';
      }

      $tokens['!'. $count] = isset($this->view->args[$count - 1]) ? check_plain($this->view->args[$count - 1]) : '';
    }

    // Now add replacements for our fields.
    foreach ($this->view->display_handler->get_handlers('field') as $field => $handler) {
      if (isset($handler->last_render)) {
        $tokens["[$field]"] = $handler->last_render;
      }
      else {
        $tokens["[$field]"] = '';
      }
      $tokens = array_merge($tokens, $item['token']);
      $this->add_self_tokens($tokens, $item);

      // We only use fields up to (and including) this one.
      if ($field == $this->options['id']) {
        break;
      }
    }
    return $tokens;
  }
}

function _sparql_views_calc_row_combinations($field_object, $values) {
  $combine_rows = array();

  // Get a list of fields that are linked to other fields if the other
  // field is excluded from display. We do this because we can combine two
  // rows if two field values are different ONLY IF the two are connected
  // in this way. Otherwise, we only combine rows if one value is different.
  $linked_fields = array();
  foreach ($field_object->view->field as $field) {
    $link_path = preg_replace('/\[|\]/', '', $field->options['alter']['path']);
    if (!empty($link_path) && $field_object->view->field[$link_path]->options['exclude'] == TRUE) {
      $linked_fields[$link_path] = $field->field_alias; 
    }
  }

  // Iterate through and see if there are other rows that are only off by one
  // for the first field through the nth field.
  foreach ($values as $key => $value) {
    for ($i = $key + 1; $i < count($values); $i++) {
      $array_diff = array_diff_assoc($values[$i], $value);
      $diff_fields = array_keys($array_diff);

      if (count($array_diff) <= 2) {
        // If there is only one distinct value, or no distinct values, then
        // combine with the first row.
        if (count($array_diff) <= 1) {
          $different_field = $diff_fields[0];
        }
        // If there are two distinct values in this row, check to see if they
        // are linked to eachother. We know that the first key of $array_diff
        // would be the $link_path because tokens for linking a field in Views
        // are only available for the fields that came before it.
        else if (count($array_diff) == 2) {
          if (isset($linked_fields[$diff_fields[0]]) && $linked_fields[$diff_fields[0]] == $diff_fields[1]) {
            $different_field = $diff_fields[1];
          }
        }

        // If there is only one different field...
        if (isset($different_field)) {
          // And if the row has not already been combined with other rows based
          // on a third field, then combine these two rows.
          if (!isset($combine_rows[$key]) || (count($combine_rows[$key]) == 1 && isset($combine_rows[$key][$different_field]))) {
            $combine_rows[$key][$different_field][] = $i;
          }
        }
      }
    }
  }
  return $combine_rows;
}